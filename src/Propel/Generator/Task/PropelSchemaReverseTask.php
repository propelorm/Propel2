<?php

/**
 * This file is part of the Propel package.
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * @license    MIT License
 */

namespace Propel\Generator\Task;

use Propel\Generator\Config\GeneratorConfig;
use Propel\Generator\Model\PropelTypes;

require_once 'phing/tasks/ext/pdo/PDOTask.php';
use \PDOTask;

/**
 * This class generates an XML schema of an existing database from
 * the database metadata.
 *
 * @author     Hans Lellelid <hans@xmpl.org>
 */
class PropelSchemaReverseTask extends PDOTask
{
    /**
     * File to contain XML database schema.
     * @var        PhingFIle
     */
    protected $xmlSchema;

    /**
     * DB encoding to use
     * @var        string
     */
    protected $dbEncoding = 'iso-8859-1';

    /**
     * DB schema to use.
     * @var        string
     */
    protected $dbSchema;

    /**
     * The datasource name (used for <database name=""> in schema.xml)
     *
     * @var        string
     */
    protected $databaseName;

    /**
     * DOM document produced.
     * @var        DOMDocument
     */
    protected $doc;

    /**
     * The document root element.
     * @var        DOMElement
     */
    protected $databaseNode;

    /**
     * Hashtable of columns that have primary keys.
     * @var        array
     */
    protected $primaryKeys;

    /**
     * Whether to use same name for phpName or not.
     * @var        boolean
     */
    protected $samePhpName;

    /**
     * whether to add vendor info or not
     * @var        boolean
     */
    protected $addVendorInfo;

    /**
     * An initialized GeneratorConfig object containing the converted Phing props.
     *
     * @var        GeneratorConfig
     */
    private $generatorConfig;

    /**
     * Gets the (optional) schema name to use.
     *
     * @return     string
     */
    public function getDbSchema()
    {
        return $this->dbSchema;
    }

    /**
     * Sets the name of a database schema to use (optional).
     *
     * @param      string $dbSchema
     */
    public function setDbSchema($dbSchema)
    {
        $this->dbSchema = $dbSchema;
    }

    /**
     * Gets the database encoding.
     *
     * @return     string
     */
    public function getDbEncoding($v)
    {
        return $this->dbEncoding;
    }

    /**
     * Sets the database encoding.
     *
     * @param      string $v
     */
    public function setDbEncoding($v)
    {
        $this->dbEncoding = $v;
    }

    /**
     * Gets the datasource name.
     *
     * @return     string
     */
    public function getDatabaseName()
    {
        return $this->databaseName;
    }

    /**
     * Sets the datasource name.
     *
     * This will be used as the <database name=""> value in the generated schema.xml
     *
     * @param      string $v
     */
    public function setDatabaseName($v)
    {
        $this->databaseName = $v;
    }

    /**
     * Sets the output name for the XML file.
     *
     * @param      PhingFile $v
     */
    public function setOutputFile(PhingFile $v)
    {
        $this->xmlSchema = $v;
    }

    /**
     * Set whether to use the column name as phpName without any translation.
     *
     * @param      boolean $v
     */
    public function setSamePhpName($v)
    {
        $this->samePhpName = (boolean) $v;
    }

    /**
     * Set whether to add vendor info to the schema.
     *
     * @param      boolean $v
     */
    public function setAddVendorInfo($v)
    {
        $this->addVendorInfo = (boolean) $v;
    }

    /**
     * Whether to use the column name as phpName without any translation.
     *
     * @return     boolean
     */
    public function isSamePhpName()
    {
        return $this->samePhpName;
    }

    /**
     * @throws     BuildException
     */
    public function main()
    {
        if (!$this->getDatabaseName()) {
            throw new BuildException("The databaseName attribute (defined in propel.project property) is required for schema reverse engineering", $this->getLocation());
        }

        //(not yet supported) $this->log("schema : " . $this->dbSchema);
        //DocumentTypeImpl docType = new DocumentTypeImpl(null, "database", null,
        //       "http://jakarta.apache.org/turbine/dtd/database.dtd");

        $this->doc = new DOMDocument('1.0', 'utf-8');
        $this->doc->formatOutput = true; // pretty printing

        $this->doc->appendChild($this->doc->createComment("Autogenerated by ".get_class($this)." class."));

        try {

            $database = $this->buildModel();
            $database->appendXml($this->doc);

            $this->log("Writing XML to file: " . $this->xmlSchema->getPath());
            $out = new FileWriter($this->xmlSchema);
            $xmlstr = $this->doc->saveXML();
            $out->write($xmlstr);
            $out->close();

        } catch (Exception $e) {
            $this->log("There was an error building XML from metadata: " . $e->getMessage(), Project::MSG_ERR);

            return false;
        }

        $this->log("Schema reverse engineering finished");
    }

    /**
     * Gets the GeneratorConfig object for this task or creates it on-demand.
     * @return     GeneratorConfig
     */
    protected function getGeneratorConfig()
    {
        if ($this->generatorConfig === null) {
            $this->generatorConfig = new GeneratorConfig();
            $this->generatorConfig->setBuildProperties($this->getProject()->getProperties());
        }

        return $this->generatorConfig;
    }

    /**
     * Builds the model classes from the database schema.
     * @return     Database The built-out Database (with all tables, etc.)
     */
    protected function buildModel()
    {
        $config = $this->getGeneratorConfig();
        $con = $this->getConnection();

        $this->log('Reading database structure...');

        $database = new Database($this->getDatabaseName());
        $database->setPlatform($config->getConfiguredPlatform($con));
        $database->setDefaultIdMethod(IdMethod::NATIVE);
        $parser = $config->getConfiguredSchemaParser($con);
        $nbTables = $parser->parse($database, $this);

        $this->log(sprintf('Successfully reverse engineered %d tables', $nbTables));

        return $database;
    }
}
