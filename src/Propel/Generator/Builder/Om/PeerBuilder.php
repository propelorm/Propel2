<?php

/**
 * This file is part of the Propel package.
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * @license MIT License
 */

namespace Propel\Generator\Builder\Om;

use Propel\Generator\Model\Table;
use Propel\Generator\Model\ForeignKey;
use Propel\Generator\Exception\EngineException;

/**
 * Generates a PHP5 base Peer class for user object model (OM).
 *
 * This class produces the base peer class (e.g. BaseMyPeer) which contains all
 * the custom-built query and manipulator methods.
 *
 * @author Hans Lellelid <hans@xmpl.org>
 */
class PeerBuilder extends AbstractPeerBuilder
{
    /**
     * Validates the current table to make sure that it won't
     * result in generated code that will not parse.
     *
     * This method may emit warnings for code which may cause problems
     * and will throw exceptions for errors that will definitely cause
     * problems.
     *
     * @throws EngineException
     */
    protected function validateModel()
    {
        parent::validateModel();

        $table = $this->getTable();

        // Check to see if any of the column constants are PHP reserved words.
        $colConstants = array();

        foreach ($table->getColumns() as $col) {
            $colConstants[] = $this->getColumnName($col);
        }

        $reservedConstants = array_map('strtoupper', ClassTools::getPhpReservedWords());

        $intersect = array_intersect($reservedConstants, $colConstants);
        if (!empty($intersect)) {
            throw new EngineException(sprintf('One or more of your column names for [%s] table conflict with a PHP reserved word (%s).', $table->getName(), implode(', ', $intersect)));
        }
    }

    /**
     * Returns the name of the current class being built.
     *
     * @return string
     */
    public function getUnprefixedClassName()
    {
        return $this->getStubPeerBuilder()->getUnprefixedClassName();
    }

    /**
     * Returns the package for the [base] peer classes.
     *
     * @return string
     */
    public function getPackage()
    {
        return parent::getPackage() . ".Base";
    }

    /**
     * Returns the namespace for the [base] peer classes.
     *
     * @return string
     */
    public function getNamespace()
    {
        if ($namespace = parent::getNamespace()) {
                return $namespace . '\\Base';
        }

        return 'Base';
    }

    /**
     * Adds class phpdoc comment and opening of class.
     *
     * @param string &$script
     */
    protected function addClassOpen(&$script)
    {
        $tableName = $this->getTable()->getName();
        $tableDesc = $this->getTable()->getDescription();

        $script .= "
/**
 * Base static class for performing query and update operations on the '$tableName' table.
 *
 * $tableDesc
 *";
        if ($this->getBuildProperty('addTimeStamp')) {
            $now = strftime('%c');
            $script .= "
 * This class was autogenerated by Propel " . $this->getBuildProperty('version') . " on:
 *
 * $now
 *";
        }

        $extendingPeerClass = '';
        $parentClass = $this->getBehaviorContent('parentClass');

        if (null !== $parentClass) {
            $extendingPeerClass = ' extends '.$parentClass;
        } elseif ('BasePeer' !== $this->basePeerClassName) {
            $extendingPeerClass = ' extends '.$this->basePeerClassName;
        }

        $script .= "
 */
abstract class ".$this->getUnqualifiedClassName(). $extendingPeerClass . " {
";
    }

    /**
     * @param string &$script
     */
    protected function addClassBody(&$script)
    {
        $this->declareClassFromBuilder($this->getStubObjectBuilder());
        $this->declareClassFromBuilder($this->getTableMapBuilder());

        parent::addClassBody($script);

        $this->declareClasses(
            '\Propel\Runtime\Propel',
            '\Propel\Runtime\Connection\ConnectionInterface',
            '\Propel\Runtime\Connection\StatementInterface',
            '\Propel\Runtime\Exception\PropelException',
            '\Propel\Runtime\Util\BasePeer',
            '\Propel\Runtime\Map\TableMap',
            '\Propel\Runtime\ActiveQuery\Criteria',
            '\PDO'
        );
    }

    /**
     * Closes class.
     * Adds closing brace at end of class and the static
     * map builder registration code.
     * @param string &$script The script will be modified in this method.
     * @see addStaticTableMapRegistration()
     */
    protected function addClassClose(&$script)
    {
        $this->applyBehaviorModifier('staticMethods', $script, '    ');

        $script .= "
} // " . $this->getUnqualifiedClassName() . "
";
        $this->addStaticTableMapRegistration($script);
    }

    /**
     * Adds the static map builder registration code.
     * @param string &$script The script will be modified in this method.
     */
    protected function addStaticTableMapRegistration(&$script)
    {
        $script .= "
// This is the static code needed to register the TableMap for this table with the main Propel class.
//
".$this->getUnqualifiedClassName()."::buildTableMap();

";
        $this->applyBehaviorModifier('peerFilter', $script, '');
    }

    /**
     * @return string
     */
    public function getTablePhpName()
    {
        return ($this->getTable()->isAbstract() ? '' : $this->getClassNameFromBuilder($this->getStubObjectBuilder()));
    }

    /**
     * Adds constant and variable declarations that go at the top of the class.
     * @param string &$script The script will be modified in this method.
     * @see addColumnNameConstants()
     */
    protected function addConstantsAndAttributes(&$script)
    {
        // apply behaviors
        $this->applyBehaviorModifier('staticConstants', $script, "    ");
        $this->applyBehaviorModifier('staticAttributes', $script, "    ");
    }

    /**
     * Adds the buildTableMap() method.
     * @param string &$script The script will be modified in this method.
     */
    protected function addBuildTableMap(&$script)
    {
        $this->declareClassFromBuilder($this->getTableMapBuilder());
        $script .= "
    /**
     * Add a TableMap instance to the database for this peer class.
     */
    public static function buildTableMap()
    {
      \$dbMap = Propel::getServiceContainer()->getDatabaseMap(" . $this->getTableMapClass() . "::DATABASE_NAME);
      if (!\$dbMap->hasTable(" . $this->getTableMapClass() . "::TABLE_NAME)) {
        \$dbMap->addTableObject(new ".$this->getTableMapClass()."());
      }
    }
";
    }

    /**
     * Adds the addSelectColumns() method.
     * @param string &$script The script will be modified in this method.
     */
    protected function addAddSelectColumns(&$script)
    {
        $script .= "
    /**
     * Add all the columns needed to create a new object.
     *
     * Note: any columns that were marked with lazyLoad=\"true\" in the
     * XML schema will not be added to the select list and only loaded
     * on demand.
     *
     * @param Criteria \$criteria object containing the columns to add.
     * @param string   \$alias    optional table alias
     * @throws PropelException Any exceptions caught during processing will be
     *         rethrown wrapped into a PropelException.
     */
    public static function addSelectColumns(Criteria \$criteria, \$alias = null)
    {
        if (null === \$alias) {";
        foreach ($this->getTable()->getColumns() as $col) {
            if (!$col->isLazyLoad()) {
                $script .= "
            \$criteria->addSelectColumn({$col->getConstantName()});";
            } // if !col->isLazyLoad
        } // foreach
        $script .= "
        } else {";
        foreach ($this->getTable()->getColumns() as $col) {
            if (!$col->isLazyLoad()) {
                $script .= "
            \$criteria->addSelectColumn(\$alias . '." . $col->getConstantColumnName()."');";
            } // if !col->isLazyLoad
        } // foreach
        $script .= "
        }";
        $script .="
    }
";
    } // addAddSelectColumns()

    /**
     * Adds the populateObjects() method.
     * @param string &$script The script will be modified in this method.
     */
    protected function addPopulateObjects(&$script)
    {
        $table = $this->getTable();
        $script .= "
    /**
     * The returned array will contain objects of the default type or
     * objects that inherit from the default.
     *
     * @param StatementInterface \$stmt
     * @return array
     * @throws PropelException Any exceptions caught during processing will be
     *         rethrown wrapped into a PropelException.
     */
    public static function populateObjects(StatementInterface \$stmt)
    {
        \$results = array();
    ";
        if (!$table->getChildrenColumn()) {
            $script .= "
        // set the class once to avoid overhead in the loop
        \$cls = static::getOMClass(false);";
        }

        $script .= "
        // populate the object(s)
        while (\$row = \$stmt->fetch(PDO::FETCH_NUM)) {
            \$key = {$this->getTableMapClassName()}::getPrimaryKeyHashFromRow(\$row, 0);
            if (null !== (\$obj = {$this->getTableMapClassName()}::getInstanceFromPool(\$key))) {
                // We no longer rehydrate the object, since this can cause data loss.
                // See http://www.propelorm.org/ticket/509
                // \$obj->hydrate(\$row, 0, true); // rehydrate
                \$results[] = \$obj;
            } else {"
        ;

        if ($table->getChildrenColumn()) {
            $script .= "
                // class must be set each time from the record row
                \$cls = static::getOMClass(\$row, 0);
                \$cls = preg_replace('#\.#', '\\\\', \$cls);
                " . $this->buildObjectInstanceCreationCode('$obj', '$cls') . "
                \$obj->hydrate(\$row);
                \$results[] = \$obj;
                {$this->getTableMapClassName()}::addInstanceToPool(\$obj, \$key);";
        } else {
            $script .= "
                " . $this->buildObjectInstanceCreationCode('$obj', '$cls') . "
                \$obj->hydrate(\$row);
                \$results[] = \$obj;
                {$this->getTableMapClassName()}::addInstanceToPool(\$obj, \$key);";
        }
        $script .= "
            } // if key exists
        }
        \$stmt->closeCursor();

        return \$results;
    }";
    }

    /**
     * Adds the populateObject() method.
     * @param string &$script The script will be modified in this method.
     */
    protected function addPopulateObject(&$script)
    {
        $table = $this->getTable();
        $script .= "
    /**
     * Populates an object of the default type or an object that inherit from the default.
     *
     * @param array \$row ConnectionInterface resultset row.
     * @param int   \$startcol The 0-based offset for reading from the resultset row.
     * @throws PropelException Any exceptions caught during processing will be
     *         rethrown wrapped into a PropelException.
     * @return array (" . $this->getObjectClassName(). " object, last column rank)
     */
    public static function populateObject(\$row, \$startcol = 0)
    {
        \$key = {$this->getTableMapClassName()}::getPrimaryKeyHashFromRow(\$row, \$startcol);
        if (null !== (\$obj = {$this->getTableMapClassName()}::getInstanceFromPool(\$key))) {
            // We no longer rehydrate the object, since this can cause data loss.
            // See http://www.propelorm.org/ticket/509
            // \$obj->hydrate(\$row, \$startcol, true); // rehydrate
            \$col = \$startcol + " . $this->getTableMapClass() . "::NUM_HYDRATE_COLUMNS;";
        if ($table->isAbstract()) {
            $script .= "
        } elseif (null == \$key) {
            // empty resultset, probably from a left join
            // since this table is abstract, we can't hydrate an empty object
            \$obj = null;
            \$col = \$startcol + " . $this->getTableMapClass() . "::NUM_HYDRATE_COLUMNS;";
        }
        $script .= "
        } else {";
        if (!$table->getChildrenColumn()) {
            $script .= "
            \$cls = " . $this->getTableMapClass() . "::OM_CLASS;";
        } else {
            $script .= "
            \$cls = static::getOMClass(\$row, \$startcol, false);";
        }
        $script .= "
            \$obj = new \$cls();
            \$col = \$obj->hydrate(\$row, \$startcol);
            {$this->getTableMapClassName()}::addInstanceToPool(\$obj, \$key);
        }

        return array(\$obj, \$col);
    }
";
    }

    /**
     * Adds a getOMClass() for non-abstract tables that have inheritance.
     * @param string &$script The script will be modified in this method.
     */
    protected function addGetOMClass_Inheritance(&$script)
    {
        $col = $this->getTable()->getChildrenColumn();
        $script .= "
    /**
     * The returned Class will contain objects of the default type or
     * objects that inherit from the default.
     *
     * @param array   \$row ConnectionInterface result row.
     * @param int     \$colnum Column to examine for OM class information (first is 0).
     * @param boolean \$withPrefix Whether or not to return the path with the class name
     * @throws PropelException Any exceptions caught during processing will be
     *         rethrown wrapped into a PropelException.
     */
    public static function getOMClass(\$row, \$colnum, \$withPrefix = true)
    {
        try {
";
        if ($col->isEnumeratedClasses()) {
            $script .= "
            \$omClass = null;
            \$classKey = \$row[\$colnum + " . ($col->getPosition() - 1) . "];

            switch (\$classKey) {
";
            foreach ($col->getChildren() as $child) {
                $script .= "
                case {$this->getTableMapClassName()}::CLASSKEY_".strtoupper($child->getKey()).":
                    \$omClass = {$this->getTableMapClassName()}::CLASSNAME_".strtoupper($child->getKey()).";
                    break;
";
            } /* foreach */
            $script .= "
                default:
                    \$omClass = {$this->getTableMapClassName()}::CLASS_DEFAULT;
";
            $script .= "
            } // switch
            if (!\$withPrefix) {
                \$omClass = preg_replace('#\.#', '\\\\', \$omClass);
            }
";
        } else { /* if not enumerated */
            $script .= "
            \$omClass = \$row[\$colnum + ".($col->getPosition()-1)."];
            \$omClass = preg_replace('#\.#', '\\\\', '.'.\$omClass);
";
        }
        $script .= "
        } catch (\Exception \$e) {
            throw new PropelException('Unable to get OM class.', \$e);
        }

        return \$omClass;
    }
";
    }

    /**
     * Adds a getOMClass() for non-abstract tables that do note use inheritance.
     * @param string &$script The script will be modified in this method.
     */
    protected function addGetOMClass_NoInheritance(&$script)
    {
        $script .= "
    /**
     * The class that the Peer will make instances of.
     *
     * If \$withPrefix is true, the returned path
     * uses a dot-path notation which is translated into a path
     * relative to a location on the PHP include_path.
     * (e.g. path.to.MyClass -> 'path/to/MyClass.php')
     *
     * @param boolean \$withPrefix Whether or not to return the path with the class name
     * @return string path.to.ClassName
     */
    public static function getOMClass(\$withPrefix = true)
    {
        return \$withPrefix ? " . $this->getTableMapClass() . "::CLASS_DEFAULT : " . $this->getTableMapClass() . "::OM_CLASS;
    }
";
    }

    /**
     * Adds a getOMClass() signature for abstract tables that do not have inheritance.
     * @param string &$script The script will be modified in this method.
     */
    protected function addGetOMClass_NoInheritance_Abstract(&$script)
    {
        $script .= "
    /**
     * The class that the Peer will make instances of.
     *
     * This method must be overridden by the stub subclass, because
     * ".$this->getObjectClassName()." is declared abstract in the schema.
     *
     * @param boolean \$withPrefix
     */
    abstract public static function getOMClass(\$withPrefix = true);
";
    }

    /**
     * Adds the doInsert() method.
     * @param string &$script The script will be modified in this method.
     */
    protected function addDoInsert(&$script)
    {
        $table = $this->getTable();
        $tableMapClass = $this->getTableMapClass();

        $script .= "
    /**
     * Performs an INSERT on the database, given a ".$this->getObjectClassName()." or Criteria object.
     *
     * @param mixed               \$values Criteria or ".$this->getObjectClassName()." object containing data that is used to create the INSERT statement.
     * @param ConnectionInterface \$con the ConnectionInterface connection to use
     * @return mixed           The new primary key.
     * @throws PropelException Any exceptions caught during processing will be
     *         rethrown wrapped into a PropelException.
     */
    public static function doInsert(\$values, ConnectionInterface \$con = null)
    {
        if (null === \$con) {
            \$con = Propel::getServiceContainer()->getWriteConnection(" . $tableMapClass  . "::DATABASE_NAME);
        }

        if (\$values instanceof Criteria) {
            \$criteria = clone \$values; // rename for clarity
        } else {
            \$criteria = \$values->buildCriteria(); // build Criteria from ".$this->getObjectClassName()." object
        }
";

        foreach ($table->getColumns() as $col) {
            if ($col->isPrimaryKey()
                && $col->isAutoIncrement()
                && 'none' !== $table->getIdMethod()
                && !$table->isAllowPkInsert()
            ) {
                $script .= "
        if (\$criteria->containsKey(".$this->getColumnConstant($col).") && \$criteria->keyContainsValue(" . $this->getColumnConstant($col) . ") ) {
            throw new PropelException('Cannot insert a value for auto-increment primary key ('.".$this->getColumnConstant($col).".')');
        }
";
                if (!$this->getPlatform()->supportsInsertNullPk()) {
                    $script .= "
        // remove pkey col since this table uses auto-increment and passing a null value for it is not valid
        \$criteria->remove(".$this->getColumnConstant($col).");
";
                }
            } elseif ($col->isPrimaryKey()
                && $col->isAutoIncrement()
                && 'none' !== $table->getIdMethod()
                && $table->isAllowPkInsert()
                && !$this->getPlatform()->supportsInsertNullPk()
            ) {
                $script .= "
        // remove pkey col if it is null since this table does not accept that
        if (\$criteria->containsKey(".$this->getColumnConstant($col).") && !\$criteria->keyContainsValue(" . $this->getColumnConstant($col) . ") ) {
            \$criteria->remove(".$this->getColumnConstant($col).");
        }
";
            }
        }

        $script .= "

        // Set the correct dbName
        \$criteria->setDbName(" . $this->getTableMapClass() . "::DATABASE_NAME);

        try {
            // use transaction because \$criteria could contain info
            // for more than one table (I guess, conceivably)
            \$con->beginTransaction();
            \$pk = ".$this->basePeerClassName."::doInsert(\$criteria, \$con);
            \$con->commit();
        } catch (PropelException \$e) {
            \$con->rollBack();
            throw \$e;
        }

        return \$pk;
    }
";
    }

    /**
     * Adds the doUpdate() method.
     * @param string &$script The script will be modified in this method.
     */
    protected function addDoUpdate(&$script)
    {
        $table = $this->getTable();
        $script .= "
    /**
     * Performs an UPDATE on the database, given a ".$this->getObjectClassName()." or Criteria object.
     *
     * @param mixed               \$values Criteria or ".$this->getObjectClassName()." object containing data that is used to create the UPDATE statement.
     * @param ConnectionInterface \$con The connection to use (specify ConnectionInterface connection object to exert more control over transactions).
     * @return int             The number of affected rows (if supported by underlying database driver).
     * @throws PropelException Any exceptions caught during processing will be
     *         rethrown wrapped into a PropelException.
     */
    public static function doUpdate(\$values, ConnectionInterface \$con = null)
    {
        if (null === \$con) {
            \$con = Propel::getServiceContainer()->getWriteConnection(" . $this->getTableMapClass() . "::DATABASE_NAME);
        }

        \$selectCriteria = new Criteria(" . $this->getTableMapClass() . "::DATABASE_NAME);

        if (\$values instanceof Criteria) {
            \$criteria = clone \$values; // rename for clarity
";
        foreach ($table->getColumns() as $col) {
            if ($col->isPrimaryKey()) {
                $script .= "
            \$comparison = \$criteria->getComparison(".$this->getColumnConstant($col).");
            \$value = \$criteria->remove(".$this->getColumnConstant($col).");
            if (\$value) {
                \$selectCriteria->add(".$this->getColumnConstant($col).", \$value, \$comparison);
            } else {
                \$selectCriteria->setPrimaryTableName(" . $this->getTableMapClass() . "::TABLE_NAME);
            }
";
            }  /* if col is prim key */
        } /* foreach */

        $script .= "
        } else { // \$values is ".$this->getObjectClassName()." object
            \$criteria = \$values->buildCriteria(); // gets full criteria
            \$selectCriteria = \$values->buildPkeyCriteria(); // gets criteria w/ primary key(s)
        }

        // set the correct dbName
        \$criteria->setDbName(" . $this->getTableMapClass() . "::DATABASE_NAME);

        return {$this->basePeerClassName}::doUpdate(\$selectCriteria, \$criteria, \$con);
    }
";
    }

    /**
     * Adds the doDeleteAll() method.
     * @param string &$script The script will be modified in this method.
     */
    protected function addDoDeleteAll(&$script)
    {
        $table = $this->getTable();
        $script .= "
    /**
     * Deletes all rows from the ".$table->getName()." table.
     *
     * @param ConnectionInterface \$con the connection to use
     * @return int The number of affected rows (if supported by underlying database driver).
     */
    public static function doDeleteAll(ConnectionInterface \$con = null)
    {
        if (null === \$con) {
            \$con = Propel::getServiceContainer()->getWriteConnection(" . $this->getTableMapClass() . "::DATABASE_NAME);
        }
        \$affectedRows = 0; // initialize var to track total num of affected rows
        try {
            // use transaction because \$criteria could contain info
            // for more than one table or we could emulating ON DELETE CASCADE, etc.
            \$con->beginTransaction();
            ";
        if ($this->isDeleteCascadeEmulationNeeded()) {
            $script .="\$affectedRows += static::doOnDeleteCascade(new Criteria(" . $this->getTableMapClass() . "::DATABASE_NAME), \$con);
            ";
        }
        if ($this->isDeleteSetNullEmulationNeeded()) {
            $script .= "static::doOnDeleteSetNull(new Criteria(" . $this->getTableMapClass() . "::DATABASE_NAME), \$con);
            ";
        }
        $script .= "\$affectedRows += {$this->basePeerClassName}::doDeleteAll(" . $this->getTableMapClass() . "::TABLE_NAME, \$con, " . $this->getTableMapClass() . "::DATABASE_NAME);
            // Because this db requires some delete cascade/set null emulation, we have to
            // clear the cached instance *after* the emulation has happened (since
            // instances get re-added by the select statement contained therein).
            {$this->getTableMapClassName()}::clearInstancePool();
            {$this->getTableMapClassName()}::clearRelatedInstancePool();

            \$con->commit();
        } catch (PropelException \$e) {
            \$con->rollBack();
            throw \$e;
        }

        return \$affectedRows;
    }
";
    }

    /**
     * Adds the doDelete() method.
     * @param string &$script The script will be modified in this method.
     */
    protected function addDoDelete(&$script)
    {
        $table = $this->getTable();
        $emulateCascade = $this->isDeleteCascadeEmulationNeeded() || $this->isDeleteSetNullEmulationNeeded();
        $script .= "
    /**
     * Performs a DELETE on the database, given a ".$this->getObjectClassName()." or Criteria object OR a primary key value.
     *
     * @param mixed               \$values Criteria or ".$this->getObjectClassName()." object or primary key or array of primary keys
     *              which is used to create the DELETE statement
     * @param ConnectionInterface \$con the connection to use
     * @return int The number of affected rows (if supported by underlying database driver).  This includes CASCADE-related rows
     *                if supported by native driver or if emulated using Propel.
     * @throws PropelException Any exceptions caught during processing will be
     *         rethrown wrapped into a PropelException.
     */
     static public function doDelete(\$values, ConnectionInterface \$con = null)
     {
        if (null === \$con) {
            \$con = Propel::getServiceContainer()->getWriteConnection(" . $this->getTableMapClass() . "::DATABASE_NAME);
        }

        if (\$values instanceof Criteria) {";
        if (!$emulateCascade) {
            $script .= "
            // invalidate the cache for all objects of this type, since we have no
            // way of knowing (without running a query) what objects should be invalidated
            // from the cache based on this Criteria.
            {$this->getTableMapClassName()}::clearInstancePool();";
        }
        $script .= "
            // rename for clarity
            \$criteria = clone \$values;
        } elseif (\$values instanceof \\".$this->getStubObjectBuilder()->getQualifiedClassName().") { // it's a model object";
        if (!$emulateCascade) {
            $script .= "
            // invalidate the cache for this single object
            {$this->getTableMapClassName()}::removeInstanceFromPool(\$values);";
        }
        if (count($table->getPrimaryKey()) > 0) {
            $script .= "
            // create criteria based on pk values
            \$criteria = \$values->buildPkeyCriteria();";
        } else {
            $script .= "
            // create criteria based on pk value
            \$criteria = \$values->buildCriteria();";
        }

        $script .= "
        } else { // it's a primary key, or an array of pks";
        $script .= "
            \$criteria = new Criteria(" . $this->getTableMapClass() . "::DATABASE_NAME);";

        if (1 === count($table->getPrimaryKey())) {
            $pkey = $table->getPrimaryKey();
            $col = array_shift($pkey);
            $script .= "
            \$criteria->add(".$this->getColumnConstant($col).", (array) \$values, Criteria::IN);";
            if (!$emulateCascade) {
                $script .= "
            // invalidate the cache for this object(s)
            foreach ((array) \$values as \$singleval) {
                {$this->getTableMapClassName()}::removeInstanceFromPool(\$singleval);
            }";
            }
        } else {
            $script .= "
            // primary key is composite; we therefore, expect
            // the primary key passed to be an array of pkey values
            if (count(\$values) == count(\$values, COUNT_RECURSIVE)) {
                // array is not multi-dimensional
                \$values = array(\$values);
            }
            foreach (\$values as \$value) {";
            $i = 0;
            foreach ($table->getPrimaryKey() as $col) {
                if (0 === $i) {
                    $script .= "
                \$criterion = \$criteria->getNewCriterion(".$this->getColumnConstant($col).", \$value[$i]);";
                } else {
                    $script .= "
                \$criterion->addAnd(\$criteria->getNewCriterion(".$this->getColumnConstant($col).", \$value[$i]));";
                }
                $i++;
            }
            $script .= "
                \$criteria->addOr(\$criterion);";
            if (!$emulateCascade) {
                $script .= "
                // we can invalidate the cache for this single PK
                {$this->getTableMapClassName()}::removeInstanceFromPool(\$value);";
            }
            $script .= "
            }";
        } /* if count(table->getPrimaryKeys()) */

        $script .= "
        }

        // Set the correct dbName
        \$criteria->setDbName(" . $this->getTableMapClass() . "::DATABASE_NAME);

        \$affectedRows = 0; // initialize var to track total num of affected rows

        try {
            // use transaction because \$criteria could contain info
            // for more than one table or we could emulating ON DELETE CASCADE, etc.
            \$con->beginTransaction();
            ";

        if ($this->isDeleteCascadeEmulationNeeded()) {
            $script .= "
            // cloning the Criteria in case it's modified by doSelect() or doSelectStmt()
            \$c = clone \$criteria;
            \$affectedRows += static::doOnDeleteCascade(\$c, \$con);
            ";
        }

        if ($this->isDeleteSetNullEmulationNeeded()) {
            $script .= "
            // cloning the Criteria in case it's modified by doSelect() or doSelectStmt()
            \$c = clone \$criteria;
            static::doOnDeleteSetNull(\$c, \$con);
            ";
        }

        if ($emulateCascade) {
            $script .= "
            // Because this db requires some delete cascade/set null emulation, we have to
            // clear the cached instance *after* the emulation has happened (since
            // instances get re-added by the select statement contained therein).
            if (\$values instanceof Criteria) {
                {$this->getTableMapClassName()}::clearInstancePool();
            } elseif (\$values instanceof \\".$this->getStubObjectBuilder()->getQualifiedClassName().") { // it's a model object
                {$this->getTableMapClassName()}::removeInstanceFromPool(\$values);
            } else { // it's a primary key, or an array of pks
                foreach ((array) \$values as \$singleval) {
                    {$this->getTableMapClassName()}::removeInstanceFromPool(\$singleval);
                }
            }
            ";
        }

        $script .= "
            \$affectedRows += {$this->basePeerClassName}::doDelete(\$criteria, \$con);
            {$this->getTableMapClassName()}::clearRelatedInstancePool();
            \$con->commit();

            return \$affectedRows;
        } catch (PropelException \$e) {
            \$con->rollBack();
            throw \$e;
        }
    }
";
    }

    /**
     * Adds the doOnDeleteCascade() method, which provides ON DELETE CASCADE emulation.
     * @param string &$script The script will be modified in this method.
     */
    protected function addDoOnDeleteCascade(&$script)
    {
        $table = $this->getTable();
        $script .= "
    /**
     * This is a method for emulating ON DELETE CASCADE for DBs that don't support this
     * feature (like MySQL or SQLite).
     *
     * This method is not very speedy because it must perform a query first to get
     * the implicated records and then perform the deletes by calling those Peer classes.
     *
     * This method should be used within a transaction if possible.
     *
     * @param Criteria            \$criteria
     * @param ConnectionInterface \$con
     * @return int The number of affected rows (if supported by underlying database driver).
     */
    protected static function doOnDeleteCascade(Criteria \$criteria, ConnectionInterface \$con)
    {
        // initialize var to track total num of affected rows
        \$affectedRows = 0;

        // first find the objects that are implicated by the \$criteria
        \$objects = {$this->getQueryClassName()}::create(null, \$criteria)->find(\$con);
        foreach (\$objects as \$obj) {
";

        foreach ($table->getReferrers() as $fk) {

            // $fk is the foreign key in the other table, so localTableName will
            // actually be the table name of other table
            $tblFK = $fk->getTable();

            $joinedTablePeerBuilder = $this->getNewPeerBuilder($tblFK);

            if (!$tblFK->isForReferenceOnly()) {
                // we can't perform operations on tables that are
                // not within the schema (i.e. that we have no map for, etc.)

                $fkClassName = $joinedTablePeerBuilder->getObjectClassName();

                if (ForeignKey::CASCADE === $fk->getOnDelete()) {

                    // backwards on purpose
                    $columnNamesF = $fk->getLocalColumns();
                    $columnNamesL = $fk->getForeignColumns();

                    $this->declareClassFromBuilder($joinedTablePeerBuilder->getTableMapBuilder());

                    $script .= "

            // delete related $fkClassName objects
            \$criteria = new Criteria(".$joinedTablePeerBuilder->getTableMapClass()."::DATABASE_NAME);
            ";
                    for ($x = 0, $xlen = count($columnNamesF); $x < $xlen; $x++) {
                        $columnFK = $tblFK->getColumn($columnNamesF[$x]);
                        $columnL = $table->getColumn($columnNamesL[$x]);

                        $script .= "
            \$criteria->add(".$joinedTablePeerBuilder->getColumnConstant($columnFK) .", \$obj->get".$columnL->getPhpName()."());";
                    }

                    $script .= "
            \$affectedRows += ".$joinedTablePeerBuilder->getPeerClassName(true)."::doDelete(\$criteria, \$con);";

                } // if cascade && fkey table name != curr table name

            } // if not for ref only
        } // foreach foreign keys
        $script .= "
        }

        return \$affectedRows;
    }
";
    } // end addDoOnDeleteCascade

    /**
     * Adds the doOnDeleteSetNull() method, which provides ON DELETE SET NULL emulation.
     * @param string &$script The script will be modified in this method.
     */
    protected function addDoOnDeleteSetNull(&$script)
    {
        $table = $this->getTable();
        $script .= "
    /**
     * This is a method for emulating ON DELETE SET NULL DBs that don't support this
     * feature (like MySQL or SQLite).
     *
     * This method is not very speedy because it must perform a query first to get
     * the implicated records and then perform the deletes by calling those Peer classes.
     *
     * This method should be used within a transaction if possible.
     *
     * @param Criteria            \$criteria
     * @param ConnectionInterface \$con
     * @return void
     */
    protected static function doOnDeleteSetNull(Criteria \$criteria, ConnectionInterface \$con)
    {

        // first find the objects that are implicated by the \$criteria
        \$objects = {$this->getQueryClassName()}::create(null, \$criteria)->find(\$con);
        foreach (\$objects as \$obj) {
";

        // This logic is almost exactly the same as that in doOnDeleteCascade()
        // it may make sense to refactor this, provided that things don't
        // get too complicated.
        foreach ($table->getReferrers() as $fk) {

            // $fk is the foreign key in the other table, so localTableName will
            // actually be the table name of other table
            $tblFK = $fk->getTable();
            $refTablePeerBuilder = $this->getNewPeerBuilder($tblFK);

            if (!$tblFK->isForReferenceOnly()) {
                // we can't perform operations on tables that are
                // not within the schema (i.e. that we have no map for, etc.)

                $fkClassName = $refTablePeerBuilder->getObjectClassName();

                if (ForeignKey::SETNULL === $fk->getOnDelete()) {

                    // backwards on purpose
                    $columnNamesF = $fk->getLocalColumns();
                    $columnNamesL = $fk->getForeignColumns(); // should be same num as foreign
                    $script .= "
            // set fkey col in related $fkClassName rows to NULL
            \$selectCriteria = new Criteria(" . $this->getTableMapClass() . "::DATABASE_NAME);
            \$updateValues = new Criteria(" . $this->getTableMapClass() . "::DATABASE_NAME);";

                    for ($x = 0, $xlen = count($columnNamesF); $x < $xlen; $x++) {
                        $columnFK = $tblFK->getColumn($columnNamesF[$x]);
                        $columnL = $table->getColumn($columnNamesL[$x]);
                        $script .= "
            \$selectCriteria->add(".$refTablePeerBuilder->getColumnConstant($columnFK).", \$obj->get".$columnL->getPhpName()."());
            \$updateValues->add(".$refTablePeerBuilder->getColumnConstant($columnFK).", null);
";
                    }

                    $script .= "
            {$this->basePeerClassName}::doUpdate(\$selectCriteria, \$updateValues, \$con); // use BasePeer because generated Peer doUpdate() methods only update using pkey
";
                } // if setnull && fkey table name != curr table name
            } // if not for ref only
        } // foreach foreign keys

        $script .= "
        }
    }
";
    }

    /**
     * Adds the getTableMap() method which is a convenience method for apps to get DB metadata.
     * @param string &$script The script will be modified in this method.
     */
    protected function addGetTableMap(&$script)
    {
        $script .= "
    /**
     * Returns the TableMap related to this peer.
     * This method is not needed for general use but a specific application could have a need.
     * @return TableMap
     * @throws PropelException Any exceptions caught during processing will be
     *         rethrown wrapped into a PropelException.
     */
    public static function getTableMap()
    {
        return Propel::getServiceContainer()->getDatabaseMap(" . $this->getTableMapClass() . "::DATABASE_NAME)->getTable(" . $this->getTableMapClass() . "::TABLE_NAME);
    }
";
    }

    /**
     * Get the column offsets of the primary key(s) for specified table.
     *
     * @param  Table $tbl
     * @return array int[] The column offsets of the primary key(s).
     */
    protected function getPrimaryKeyColOffsets(Table $tbl)
    {
        $offsets = array();
        $idx = 0;
        foreach ($tbl->getColumns() as $col) {
            if ($col->isPrimaryKey()) {
                $offsets[] = $idx;
            }
            $idx++;
        }

        return $offsets;
    }

    /**
     * @param  ForeignKey  $fk
     * @param  Table       $table
     * @param  Table       $joinTable
     * @param  PeerBuilder $joinedTablePeerBuilder
     * @return string
     */
    public function addCriteriaJoin($fk, $table, $joinTable, $joinedTablePeerBuilder)
    {
        $script = '';
        $lfMap = $fk->getLocalForeignMapping();
        $lftCols = $fk->getLocalColumns();
        if (1 === count($lftCols)) {
            // simple foreign key
            $lftCol = $lftCols[0];
            $script .= sprintf(
                "
        \$criteria->addJoin(%s, %s, \$joinBehavior);
",
                $this->getColumnConstant($table->getColumn($lftCol)),
                $joinedTablePeerBuilder->getColumnConstant($joinTable->getColumn($lfMap[$lftCol]))
            );
        } else {
            // composite foreign key
            $script .= "
        \$criteria->addMultipleJoin(array(
";
            foreach ($lftCols as $columnName) {
                $script .= sprintf(
                    "        array(%s, %s),
",
                    $this->getColumnConstant($table->getColumn($columnName)),
                    $joinedTablePeerBuilder->getColumnConstant($joinTable->getColumn($lfMap[$columnName]))
                );
            }
            $script .= "      ), \$joinBehavior);
";
        }

        return $script;
    }

    /**
     * returns the desired join behavior as set in the build properties
     * see trac ticket #588, #491
     * @return string
     */
    protected function getJoinBehavior()
    {
        return $this->getGeneratorConfig()->getBuildProperty('useLeftJoinsInDoJoinMethods') ? 'Criteria::LEFT_JOIN' : 'Criteria::INNER_JOIN';
    }
}
