<?php

/**
 * This file is part of the Propel package.
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * @license MIT License
 */

namespace Propel\Generator\Builder\Om;

use Propel\Generator\Model\ForeignKey;

use Propel\Generator\Model\IdMethod;
use Propel\Generator\Platform\PlatformInterface;

/**
 * Generates the PHP5 table map class for user object model (OM).
 *
 * @author Hans Lellelid <hans@xmpl.org>
 */
class TableMapBuilder extends AbstractOMBuilder
{
    /**
     * Gets the package for the map builder classes.
     * @return string
     */
    public function getPackage()
    {
        return parent::getPackage() . '.Map';
    }

    public function getNamespace()
    {
        if (!$namespace = parent::getNamespace()) {
            return 'Map';
        }

        if ($this->getGeneratorConfig()
            && $omns = $this->getGeneratorConfig()->getBuildProperty('namespaceMap')) {
            return $namespace . '\\' . $omns;
        }

        return $namespace .'Map';
    }

    /**
     * Returns the name of the current class being built.
     * @return string
     */
    public function getUnprefixedClassName()
    {
        return $this->getTable()->getPhpName() . 'TableMap';
    }

    /**
     * Adds class phpdoc comment and opening of class.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addClassOpen(&$script)
    {
        $table = $this->getTable();
        $script .= "

/**
 * This class defines the structure of the '".$table->getName()."' table.
 *
 *";
        if ($this->getBuildProperty('addTimeStamp')) {
            $now = strftime('%c');
            $script .= "
 * This class was autogenerated by Propel " . $this->getBuildProperty('version') . " on:
 *
 * $now
 *";
        }
        $script .= "
 *
 * This map class is used by Propel to do runtime db structure discovery.
 * For example, the createSelectSql() method checks the type of a given column used in an
 * ORDER BY clause to know whether it needs to apply SQL to make the ORDER BY case-insensitive
 * (i.e. if it's a text column type).
 *
 */
class ".$this->getUnqualifiedClassName()." extends TableMap
{
    use InstancePoolTrait;
";
    }

    /**
     * Specifies the methods that are added as part of the map builder class.
     * This can be overridden by subclasses that wish to add more methods.
     * @see ObjectBuilder::addClassBody()
     */
    protected function addClassBody(&$script)
    {
        $table = $this->getTable();

        $this->declareClasses(
            '\Propel\Runtime\ActiveQuery\InstancePoolTrait',
            '\Propel\Runtime\Map\TableMap',
            '\Propel\Runtime\Map\RelationMap',
            '\Propel\Runtime\Propel'
        );

        $script .= $this->addConstants();

        $this->addInheritanceColumnConstants($script);
        if ($table->hasEnumColumns()) {
            $this->addEnumColumnConstants($script);
        }

        // apply behaviors
        $this->applyBehaviorModifier('staticConstants', $script, "    ");
        $this->applyBehaviorModifier('staticAttributes', $script, "    ");

        $this->addAttributes($script);

        if ($table->hasEnumColumns()) {
            $this->addEnumColumnAttributes($script);
            $this->addGetValueSets($script);
            $this->addGetValueSet($script);
        }

        $this->addInitialize($script);
        $this->addBuildRelations($script);
        $this->addGetBehaviors($script);

        $script .= $this->addInstancePool();
        $script .= $this->addClearRelatedInstancePool();

        $this->addGetPrimaryKeyHash($script);
        $this->addGetPrimaryKeyFromRow($script);
    }

    /**
     * Adds any constants needed for this TableMap class.
     *
     * @return string
     */
    protected function addConstants()
    {
        return $this->renderTemplate('tableMapConstants', array(
            'className'         => $this->getClasspath(),
            'dbName'            => $this->getDatabase()->getName(),
            'tableName'         => $this->getTable()->getName(),
            'tablePhpName'      => $this->getTable()->isAbstract() ? '' : addslashes($this->getStubObjectBuilder()->getFullyQualifiedClassName()),
            'classPath'         => $this->getStubObjectBuilder()->getClasspath(),
            'nbColumns'         => $this->getTable()->getNumColumns(),
            'nbLazyLoadColumns' => $this->getTable()->getNumLazyLoadColumns(),
            'nbHydrateColumns'  => $this->getTable()->getNumColumns() - $this->getTable()->getNumLazyLoadColumns(),
            'peerClassName'     => $this->getStubPeerBuilder()->getFullyQualifiedClassName(),
            'columns'           => $this->getTable()->getColumns(),
            'stringFormat'      => $this->getTable()->getDefaultStringFormat(),
        ));
    }

    /**
     * Adds the COLUMN_NAME constant to the class definition.
     * @param string &$script The script will be modified in this method.
     */
    protected function addColumnNameConstants(&$script)
    {
        foreach ($this->getTable()->getColumns() as $col) {
            $script .= "
    /**
     * the column name for the " . strtoupper($col->getName()) ." field
     */
    const ".$col->getConstantColumnName() ." = '" . $this->getTable()->getName() . ".".strtoupper($col->getName())."';
";
        } // foreach
    }

    /**
     * Adds the valueSet constants for ENUM columns.
     * @param string &$script The script will be modified in this method.
     */
    protected function addEnumColumnConstants(&$script)
    {
        foreach ($this->getTable()->getColumns() as $col) {
            if ($col->isEnumType()) {
                $script .= "
    /** The enumerated values for the " . strtoupper($col->getName()) . " field */";
                foreach ($col->getValueSet() as $value) {
                    $script .= "
    const " . $col->getConstantColumnName() . '_' . $this->getEnumValueConstant($value) . " = '" . $value . "';";
                }
                $script .= "
";
            }
        }
    }

    /**
     * Adds the valueSet attributes for ENUM columns.
     * @param string &$script The script will be modified in this method.
     */
    protected function addEnumColumnAttributes(&$script)
    {
        $script .= "
    /** The enumerated values for this table */
    protected static \$enumValueSets = array(";
        foreach ($this->getTable()->getColumns() as $col) {
            if ($col->isEnumType()) {
                $script .= "
                {$col->getConstantName()} => array(
                ";
                foreach ($col->getValueSet() as $value) {
                    $script .= "            self::" . $col->getConstantColumnName() . '_' . $this->getEnumValueConstant($value) . ",
";
                }
                $script .= "        ),";
            }
        }
        $script .= "
    );
";
    }

    /**
     * Adds the getValueSets() method.
     * @param string &$script The script will be modified in this method.
     */
    protected function addGetValueSets(&$script)
    {
        $script .= "
    /**
     * Gets the list of values for all ENUM columns
     * @return array
     */
    public static function getValueSets()
    {
      return static::\$enumValueSets;
    }
";
    }

    /**
     * Adds the getValueSet() method.
     * @param string &$script The script will be modified in this method.
     */
    protected function addGetValueSet(&$script)
    {
        $script .= "
    /**
     * Gets the list of values for an ENUM column
     * @param string \$colname
     * @return array list of possible values for the column
     */
    public static function getValueSet(\$colname)
    {
        \$valueSets = self::getValueSets();

        return \$valueSets[\$colname];
    }
";
    }

    /**
     * Adds the CLASSKEY_* and CLASSNAME_* constants used for inheritance.
     * @param string &$script The script will be modified in this method.
     */
    public function addInheritanceColumnConstants(&$script)
    {
        if (!$col = $this->getTable()->getChildrenColumn()) {
            return;
        }

        if (!$col->isEnumeratedClasses()) {
            return;
        }

        foreach ($col->getChildren() as $child) {
            $childBuilder = $this->getMultiExtendObjectBuilder();
            $childBuilder->setChild($child);
            $fqcn = addslashes($childBuilder->getFullyQualifiedClassName());

            $script .= "
    /** A key representing a particular subclass */
    const CLASSKEY_".strtoupper($child->getKey())." = '" . $child->getKey() . "';
";

            if (strtoupper($child->getClassName()) != strtoupper($child->getKey())) {
                $script .= "
    /** A key representing a particular subclass */
    const CLASSKEY_".strtoupper($child->getClassname())." = '" . $fqcn . "';
";
            }

            $script .= "
    /** A class that can be returned by this peer. */
    const CLASSNAME_".strtoupper($child->getKey())." = '". $fqcn . "';
";
        }
    }

    /**
     * @param  string $value
     * @return string
     */
    protected function getEnumValueConstant($value)
    {
        return strtoupper(preg_replace('/[^a-zA-Z0-9_\x7f-\xff]/', '_', $value));
    }

    /**
     * Adds any attributes needed for this TableMap class.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addAttributes(&$script)
    {
    }

    /**
     * Closes class.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addClassClose(&$script)
    {
        $script .= "
} // " . $this->getUnqualifiedClassName() . "
";
        $this->applyBehaviorModifier('tableMapFilter', $script, "");
    }

    /**
     * Adds the addInitialize() method to the  table map class.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addInitialize(&$script)
    {

        $table = $this->getTable();
        $platform = $this->getPlatform();

        $script .= "
    /**
     * Initialize the table attributes and columns
     * Relations are not initialized by this method since they are lazy loaded
     *
     * @return void
     * @throws PropelException
     */
    public function initialize()
    {
        // attributes
        \$this->setName('".$table->getName()."');
        \$this->setPhpName('".$table->getPhpName()."');
        \$this->setClassName('" . addslashes($this->getStubObjectBuilder()->getFullyQualifiedClassName()) . "');
        \$this->setPackage('" . parent::getPackage() . "');";
        if ($table->getIdMethod() == "native") {
            $script .= "
        \$this->setUseIdGenerator(true);";
        } else {
            $script .= "
        \$this->setUseIdGenerator(false);";
        }

        if ($table->getIdMethodParameters()) {
            $params = $table->getIdMethodParameters();
            $imp = $params[0];
            $script .= "
        \$this->setPrimaryKeyMethodInfo('".$imp->getValue()."');";
        } elseif ($table->getIdMethod() == IdMethod::NATIVE && ($platform->getNativeIdMethod() == PlatformInterface::SEQUENCE || $platform->getNativeIdMethod() == PlatformInterface::SERIAL)) {
            $script .= "
        \$this->setPrimaryKeyMethodInfo('".$platform->getSequenceName($table)."');";
        }

        if ($this->getTable()->getChildrenColumn()) {
            $script .= "
        \$this->setSingleTableInheritance(true);";
        }

        if ($this->getTable()->getIsCrossRef()) {
            $script .= "
        \$this->setIsCrossRef(true);";
        }

        // Add columns to map
            $script .= "
        // columns";
        foreach ($table->getColumns() as $col) {
            $cup = strtoupper($col->getName());
            $cfc = $col->getPhpName();
            if (!$col->getSize()) {
                $size = "null";
            } else {
                $size = $col->getSize();
            }
            $default = $col->getDefaultValueString();
            if ($col->isPrimaryKey()) {
                if ($col->isForeignKey()) {
                    foreach ($col->getForeignKeys() as $fk) {
                        $script .= "
        \$this->addForeignPrimaryKey('$cup', '$cfc', '".$col->getType()."' , '".$fk->getForeignTableName()."', '".strtoupper($fk->getMappedForeignColumn($col->getName()))."', ".($col->isNotNull() ? 'true' : 'false').", ".$size.", $default);";
                    }
                } else {
                    $script .= "
        \$this->addPrimaryKey('$cup', '$cfc', '".$col->getType()."', ".var_export($col->isNotNull(), true).", ".$size.", $default);";
                }
            } else {
                if ($col->isForeignKey()) {
                    foreach ($col->getForeignKeys() as $fk) {
                        $script .= "
        \$this->addForeignKey('$cup', '$cfc', '".$col->getType()."', '".$fk->getForeignTableName()."', '".strtoupper($fk->getMappedForeignColumn($col->getName()))."', ".($col->isNotNull() ? 'true' : 'false').", ".$size.", $default);";
                    }
                } else {
                    $script .= "
        \$this->addColumn('$cup', '$cfc', '".$col->getType()."', ".var_export($col->isNotNull(), true).", ".$size.", $default);";
                }
            } // if col-is prim key
            if ($col->isEnumType()) {
                $script .= "
        \$this->getColumn('$cup', false)->setValueSet(" . var_export($col->getValueSet(), true). ");";
            }
            if ($col->isPrimaryString()) {
                $script .= "
        \$this->getColumn('$cup', false)->setPrimaryString(true);";
            }
        } // foreach

        $script .= "
    } // initialize()
";

    }

    /**
     * Adds the method that build the RelationMap objects
     * @param      string &$script The script will be modified in this method.
     */
    protected function addBuildRelations(&$script)
    {
        $script .= "
    /**
     * Build the RelationMap objects for this table relationships
     */
    public function buildRelations()
    {";
        foreach ($this->getTable()->getForeignKeys() as $fkey) {
            $columnMapping = 'array(';
            foreach ($fkey->getLocalForeignMapping() as $key => $value) {
                $columnMapping .= "'$key' => '$value', ";
            }
            $columnMapping .= ')';
            $onDelete = $fkey->hasOnDelete() ? "'" . $fkey->getOnDelete() . "'" : 'null';
            $onUpdate = $fkey->hasOnUpdate() ? "'" . $fkey->getOnUpdate() . "'" : 'null';
            $script .= "
        \$this->addRelation('" . $this->getFKPhpNameAffix($fkey) . "', '" . addslashes($this->getNewStubObjectBuilder($fkey->getForeignTable())->getFullyQualifiedClassName()) . "', RelationMap::MANY_TO_ONE, $columnMapping, $onDelete, $onUpdate);";
        }
        foreach ($this->getTable()->getReferrers() as $fkey) {
            $relationName = $this->getRefFKPhpNameAffix($fkey);
            $columnMapping = 'array(';
            foreach ($fkey->getForeignLocalMapping() as $key => $value) {
                $columnMapping .= "'$key' => '$value', ";
            }
            $columnMapping .= ')';
            $onDelete = $fkey->hasOnDelete() ? "'" . $fkey->getOnDelete() . "'" : 'null';
            $onUpdate = $fkey->hasOnUpdate() ? "'" . $fkey->getOnUpdate() . "'" : 'null';
            $script .= "
        \$this->addRelation('$relationName', '" . addslashes($this->getNewStubObjectBuilder($fkey->getTable())->getFullyQualifiedClassName()) . "', RelationMap::ONE_TO_" . ($fkey->isLocalPrimaryKey() ? "ONE" : "MANY") .", $columnMapping, $onDelete, $onUpdate";
            if ($fkey->isLocalPrimaryKey()) {
                 $script .= ");";
            } else {
                $script .= ", '" . $this->getRefFKPhpNameAffix($fkey, true) . "');";
            }
        }
        foreach ($this->getTable()->getCrossFks() as $fkList) {
            list(, $crossFK) = $fkList;
            $relationName = $this->getFKPhpNameAffix($crossFK);
            $pluralName = "'" . $this->getFKPhpNameAffix($crossFK, true) . "'";
            $onDelete = $crossFK->hasOnDelete() ? "'" . $crossFK->getOnDelete() . "'" : 'null';
            $onUpdate = $crossFK->hasOnUpdate() ? "'" . $crossFK->getOnUpdate() . "'" : 'null';
            $script .= "
        \$this->addRelation('$relationName', '" . addslashes($this->getNewStubObjectBuilder($crossFK->getForeignTable())->getFullyQualifiedClassName()) . "', RelationMap::MANY_TO_MANY, array(), $onDelete, $onUpdate, $pluralName);";
        }
        $script .= "
    } // buildRelations()
";
    }

    /**
     * Adds the behaviors getter
     * @param      string &$script The script will be modified in this method.
     */
    protected function addGetBehaviors(&$script)
    {
        if ($behaviors = $this->getTable()->getBehaviors()) {
            $script .= "
    /**
     *
     * Gets the list of behaviors registered for this table
     *
     * @return array Associative array (name => parameters) of behaviors
     */
    public function getBehaviors()
    {
        return array(";
            foreach ($behaviors as $behavior) {
                $script .= "
            '{$behavior->getName()}' => array(";
                foreach ($behavior->getParameters() as $key => $value) {
                    $script .= "'$key' => ";
                    if (is_array($value)) {
                        $string = var_export($value, true);
                        $string = str_replace("\n", '', $string);
                        $string = str_replace('  ', '', $string);
                        $script .= $string.", ";
                    } else {
                        $script .= "'$value', ";
                    }
                }
                $script .= "),";
            }
            $script .= "
        );
    } // getBehaviors()
";
        }
    }

    /**
     * Adds the PHP code to return a instance pool key for the passed-in primary key variable names.
     *
     * @param  array  $pkphp An array of PHP var names / method calls representing complete pk.
     * @return string
     */
    public function getInstancePoolKeySnippet($pkphp)
    {
        $pkphp = (array) $pkphp; // make it an array if it is not.
        $script = '';
        if (count($pkphp) > 1) {
            $script .= "serialize(array(";
            $i = 0;
            foreach ($pkphp as $pkvar) {
                $script .= ($i++ ? ', ' : '') . "(string) $pkvar";
            }
            $script .= "))";
        } else {
            $script .= "(string) " . $pkphp[0];
        }

        return $script;
    }

    public function addInstancePool()
    {
        //No need to overide instancePool if the PK is not composite
        if (!$this->getTable()->hasCompositePrimaryKey()) {
            return '';
        }

        $pks = $this->getTable()->getPrimaryKey();

        $add = array();
        $removeObjects = array();
        foreach ($pks as $pk) {
            $add[] = '$obj->get' . $pk->getPhpName() . '()';
            $removeObjects[] = '$value->get' . $pk->getPhpName() . '()';
        }
        $addInstancePoolKeySnippet = $this->getInstancePoolKeySnippet($add);
        $removeInstancePoolKeySnippetObjects = $this->getInstancePoolKeySnippet($removeObjects);

        $removePks = array();
        for ($i = 0; $i < count($pks); $i++) {
            $removePks[] = "\$value[$i]";
        }
        $removeInstancePoolKeySnippetPks = $this->getInstancePoolKeySnippet($removePks);

        return $this->renderTemplate('tableMapInstancePool', array(
                'objectClassName'                     => $this->getStubObjectBuilder()->getClassName(),
                'addInstancePoolKeySnippet'           => $addInstancePoolKeySnippet,
                'removeInstancePoolKeySnippetObjects' => $removeInstancePoolKeySnippetObjects,
                'removeInstancePoolKeySnippetPks'     => $removeInstancePoolKeySnippetPks,
                'countPks'                            => count($pks)
        ));
    }

    public function addClearRelatedInstancePool()
    {
        $table = $this->getTable();
        $relatedClassNames = array();

        // Handle ON DELETE CASCADE for updating instance pool
        foreach ($table->getReferrers() as $fk) {
            // $fk is the foreign key in the other table, so localTableName will
            // actually be the table name of other table
            $tblFK = $fk->getTable();

            $joinedTableTableMapBuilder = $this->getNewStubPeerBuilder($tblFK)->getTableMapBuilder();
            $this->declareClassFromBuilder($joinedTableTableMapBuilder);

            if (!$tblFK->isForReferenceOnly()) {
                // we can't perform operations on tables that are
                // not within the schema (i.e. that we have no map for, etc.)

                if (ForeignKey::CASCADE === $fk->getOnDelete()  || ForeignKey::SETNULL === $fk->getOnDelete()) {
                    $class = $this->getClassNameFromBuilder($joinedTableTableMapBuilder);
                    $relatedClassNames[$class] = $class;
                }
            }
        }

        if (0 == count($relatedClassNames)) {
            return '';
        }

        return $this->renderTemplate('tableMapClearRelatedInstancePool', array(
                'tableName'            => $table->getName(),
                'relatedClassNames'   => $relatedClassNames,
        ));
    }

    /**
     * Checks whether any registered behavior on that table has a modifier for a hook
     * @param  string  $hookName The name of the hook as called from one of this class methods, e.g. "preSave"
     * @return boolean
     */
    public function hasBehaviorModifier($hookName, $modifier = null)
    {
        return parent::hasBehaviorModifier($hookName, 'TableMapBuilderModifier');
    }

    /**
     * Checks whether any registered behavior on that table has a modifier for a hook
     * @param string $hookName The name of the hook as called from one of this class methods, e.g. "preSave"
     * @param string &$script The script will be modified in this method.
     */
    public function applyBehaviorModifier($hookName, &$script, $tab = "        ")
    {
        return $this->applyBehaviorModifierBase($hookName, 'TableMapBuilderModifier', $script, $tab);
    }

    /**
     * Adds method to get a version of the primary key that can be used as a unique key for identifier map.
     *
     * @param string &$script The script will be modified in this method.
     */
    protected function addGetPrimaryKeyHash(&$script)
    {
        $script .= "
    /**
     * Retrieves a string version of the primary key from the DB resultset row that can be used to uniquely identify a row in this table.
     *
     * For tables with a single-column primary key, that simple pkey value will be returned.  For tables with
     * a multi-column primary key, a serialize()d version of the primary key will be returned.
     *
     * @param array \$row ConnectionInterface resultset row.
     * @param int   \$startcol The 0-based offset for reading from the resultset row.
     * @return string A string version of PK or NULL if the components of primary key in result array are all null.
     */
    public static function getPrimaryKeyHashFromRow(\$row, \$startcol = 0)
    {";

        // We have to iterate through all the columns so that we know the offset of the primary
        // key columns.
        $n = 0;
        $pk = array();
        $cond = array();
        foreach ($this->getTable()->getColumns() as $col) {
            if (!$col->isLazyLoad()) {
                if ($col->isPrimaryKey()) {
                    $part = $n ? "\$row[\$startcol + $n]" : "\$row[\$startcol]";
                    $cond[] = $part . " === null";
                    $pk[] = $part;
                }
                $n++;
            }
        }

        $script .= "
        // If the PK cannot be derived from the row, return NULL.
        if (".implode(' && ', $cond).") {
            return null;
        }

        return ".$this->getInstancePoolKeySnippet($pk).";
    }
";
    }

    /**
     * Adds method to get the primary key from a row
     * @param string &$script The script will be modified in this method.
     */
    protected function addGetPrimaryKeyFromRow(&$script)
    {
        $script .= "
    /**
     * Retrieves the primary key from the DB resultset row
     * For tables with a single-column primary key, that simple pkey value will be returned.  For tables with
     * a multi-column primary key, an array of the primary key columns will be returned.
     *
     * @param array \$row ConnectionInterface resultset row.
     * @param int   \$startcol The 0-based offset for reading from the resultset row.
     * @return mixed The primary key of the row
     */
    public static function getPrimaryKeyFromRow(\$row, \$startcol = 0)
    {";

        // We have to iterate through all the columns so that we
        // know the offset of the primary key columns.
        $table = $this->getTable();
        $n = 0;
        $pks = array();
        foreach ($table->getColumns() as $col) {
            if (!$col->isLazyLoad()) {
                if ($col->isPrimaryKey()) {
                    $pk = '(' . $col->getPhpType() . ') ' . ($n ? "\$row[\$startcol + $n]" : "\$row[\$startcol]");
                    if ($table->hasCompositePrimaryKey()) {
                        $pks[] = $pk;
                    }
                }
                $n++;
            }
        }

        if ($table->hasCompositePrimaryKey()) {
            $script .= "

            return array(" . implode($pks, ', '). ");";
        } else {
            $script .= "

            return " . $pk . ";";
        }

        $script .= "
    }
    ";
    }
}
